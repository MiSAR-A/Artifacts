# RQ2: PIM Metamodel

<br/>

PIM metamodel diagram is provided below (click on the image to view it in full size)

<img src="https://github.com/MiSAR-A/Journal-Results/blob/master/RQ2-PIM/images/PIM.png" />

<br/>

As a result of our empirical study, we introduce our updated version of **MISAR** microservice architecture metamodel as shown in the above Figure. The new version aimed to be generic, extendible and more comprehensive in order to model almost any microservice architecture built in any platform or technology.  In regard to RQ2, this metamodel is supposed to comprehensively model microservices along with service pattern components implemented in them including server components and client components. Our enhanced metamodel is intended to provide a way to define microservice architecture from static structure and dynamic interaction points of view. Explanation of updated concepts in the result model is provided as the following:

PSM Concept | PSM Attribute(s) | Description
------------ | ------------- | -------------
`MicroservicesArchitectureModel` | `ArchitectureName` | It models microservice architecture from *static* and *interaction* points of view. It particularly represents: <br/><br/>**(a) deployment** aspect concerning the environment where microservices are deployed to. Elements capturing that aspect include: `Ambient` and `Container`, <br/><br/>**(b) microservice repository** aspect concerning the set of all microservices, their types, e.g. functional or infrastructure, and pattern components. Elements capturing that aspect include: `Microservice`, `FunctionalMicroservice`, `InfrastructureMicroservice`, `ServicePatternComponent`, `ServerComponent` and `ClientComponent`. <br/><br/>**(c) interaction interface** aspect concerning the messaging mechanism that microservices use to communicate with its clients. It defines two basic interaction styles; *synchronous* and *asynchronous*. Elements capturing that aspect include: `ServiceInterface`, `ServiceDestination`, `SynchronousServiceDestination`, `RestEndpoint`, `AsynchronousServiceDestination`, `AmqpExchange`, `AmqpQueue`, `InboundQueue`, `OutboundQueue`, `ServiceOperation` and `ServiceMessage`. <br/><br/>**(d) inter-microservice interaction** aspect concerning the inter-service dependency and exchange of information communication among microservices composing an architecture. It doesn’t represent communications that occur from outside the architecture. One element capturing this aspect is `ServiceDependency`. 
`ServicePatternComponent`| `PatternCategory`, `ComponentRole` | [Service Pattern](https://microservices.io/patterns/microservices.html) in a micoservice is the answer of a particular concern or question about micoservice that is related to its infrastructure, communication and other non-functional areas separate from its business logic. Examples of common microservice patterns include: *service registry*, *service discovery*, *service routing*, *service security*, *client resiliency* and *data storage*. These patterns are implemented by frameworks, e.g. [Spring Cloud and Netflix OOS](https://cloud.spring.io/spring-cloud-netflix/spring-cloud-netflix.html), as components to handle cross-cutting concerns of all microservices com-posing an architecture. Our enhanced model introduces this element to abstract the infrastructure patterns defined separately in the previous model. This element allows to represent any pattern or concern component that can be used in a microservice. It is defined by pattern category and the role of the component. <br/><br/>For the sake of our study, we define nine pattern categories in an enumeration type that consists of **Centralized Configuration**, **Service Routing** (e.g. API gateway), **Service Discovery**, **Service Registry**, **Service Client Resiliency** (e.g. circuit breaker and load balancer), **Service Security** (e.g. OAuth2 token-based and web security), **Data Store** (e.g. in-memory, persistent and cache), **Asynchronous Messaging**, **Service Observability** (e,g, log analysis, monitoring and tracing) and **Miscellaneous** (i.e. any infrastructure pattern not listed).
`ServerComponent` | | This element is an extension of `ServicePatternComponent` element and it represents a component that provides a service. For instance, a microservice with server component of *Service Discovery* pattern, e.g. Netflix Eureka, is considered a discovery server that other microservices request it to locate remote service instances.
`ClientComponent` | | this element is an extension of `ServicePatternComponent` element and it represents a component that requests a service. For instance, a microservice with client component of *Service Discovery* pattern, e.g. Netflix Eureka, is considered a discovery client that requests a discovery server to locate remote service instances.  
`ServiceInterface` | | It represents the operations exposed by the microservice to its clients, i.e. API. The nature of the API definition depends on which inter service communication mech-anism adopted by the microservice. If asynchronous messaging is used, the API consists of the message queues and the message types. If REST is used, the API consists of the Endpoint URI’s and request and response message formats. In our analysis, we found that many services typically used a combination of these two interaction styles. In future, other communication protocols and APIs may be invented. Therefore, we made `ServiceInterface` an abstract type defined by generic destinations and messages to represent any type of communication APIs.
`ServiceDestination` | | this element represents how a client mircroservice can reach the data or service operation offered by a microservice whether synchronously or asynchronously. `ServiceDestination` is either `SynchronousServiceDestination` or `AsynchronousServiceDestination` and maps to zero or one `ServiceOperation` (zero multiplicity represent the case when the service operation exists yet is hidden from source artifacts).
`ServiceOperation` | `OperationName`, `OperationName` | this element represents the documentation of service operation corresponding to a `ServiceDestination`. It is attributed by method name and description that consists simply from class name of request message and/or class name of response message. 
`SynchronousServiceDestination` | | Although synchronous microservice interaction was represented implicitly in previous version, only REST protocol was taken into consideration. In the enhanced model, we decided to add this abstract superclass to allow the extension to for other synchronous protocols such as Thrift or any domain specific protocol. 
`AsynchronousServiceDestination` | | this element was added to capture service communication style that uses asynchronous messaging protocols rather than synchronous request-response style. This pattern has many benefits as it decouples client from services, the messages are buffered by message broker until the consumer is able to process them and it supports a variety of communication patterns including notifications and publish/subscribe. Widely used protocols of this style include *AMQP*, *STOMP* and *MQTT* that can be extended from this abstract element.
`RestEndpoint` | `Path`, `HttpMethod` | this element adds more details to `ServiceDestination` element according to *REST* protocol. It represents the request endpoint exposed by the microservice and is attributed by Path which is the por-tion of service operation URI that directly follows: `http|https://<host-name>:<port-number>`. It is also attributed by `HttpMethod`, i.e. `GET`/`POST`/`PUT`/`DELETE`. 
`AmqpExchange` | `ExchangeName`, `ExchangeType`, `RoutingKeys` | this element adds more details to `ServiceDestination` element according to *AMQP* protocol. It is attributed by `ExchangeName`, `ExchangeType` (e.g. Direct, Fanout or Topic) and `RoutingKeys`. Exchange in AMQP protocol accepts messages from the producer application and routes them to message queues with help of routing keys.
`AmqpQueue` | `QueueName` | this element adds more details to `ServiceDestination` element according to *AMQP* protocol. It is attributed by `QueueName`. It represents where the publisher microservice writes its message, i.e. `OutboundQueue`, or where the subscriber microservice receives messages, i.e. `InboundQueue`.
`InboundQueue` | | 
`OutboundQueue` | | 
`ServiceMessage` | `MessageType`, `BodySchema`, `SchemaFormat` | this element is added in our model as it is important to know the format of messages generated by a microservice so that other microservices become able to send requests correctly and benefit from that service. It is defined by its `BodySchema`, `SchemaFormat`, e.g. *JSON*, *XML* or *YAML*, and `MessageType`, e.g. *Request*, *Response* or *Error*.
`ServiceDependency` | | this element describes one interaction between two services; from *consumer* service, i.e. the microservice itself, towards one *provider* service, i.e. remote mcroservice, through one destination of the provider service. This interaction could occur synchronously in a request/response manner or asynchronously in publish/subscribe manner. 
