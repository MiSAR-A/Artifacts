# RQ1: PSM Metamodel

<br/>

PSM metamodel diagram is provided below (click on the image to view it in full size)

<img src="https://github.com/MiSAR-A/Journal-Results/blob/master/RQ1-PSM/images/PSM.png" />

<br/>

Source artifacts of each microservice architecture projects used in our study were packaged and uploaded into one GitHub repository. Artefacts contained in each repository can be classified into two main elements:

## 1. SystemProjectArtifactsModel

PSM concepts that map to *system-level* classifiaction of artifacts are provided in the table below: 

PSM Concept | PSM Attribute(s) | Description
------------ | ------------- | -------------
`SystemProjectArtifactsModel` | `ProjectName`, `ArtifactsRepositoryURI` | represents the *system-level* project artefacts. `SystemProjectArtifactsModel` is described by architecture’s project name and its root repository URI. 
`SystemProjectArtifactFile`| `FileName` | this element generalizes files that configure building, orchestrating and integrating all modules/application projects aggregated in a microservice-based architecture project. `SystemProjectArtifactFile` element is described by its file name including full path as well as by the system’s project name to which this file belongs. According to our empirical study, there were two classes of such file type appeared in all stud-ies, namely, `DockerComposeFile` and `SystemProjectBuildFile`. Aiming to make our PSM extendible and reusable, we assumed that there may be more than two subtypes of such file.
`DockerComposeFile` | | this element maps to Docker compose file, i.e. a YAML file that defines orchestration of microservice applica-tions’ containers at runtime and other network-related information, i.e. links among containers. One `DockerComposeFile` represents one consolidated Docker compose file that has many service definition keys, mapped to `ContainerDefinition` elements, each has zero or many ‘links’ / ’depends_on’ keys, mapped to `ContainerDependency` elements.
`ContainerDefinition` | `ServiceName`, `ImageField`, `BuildField`, `LoggingField`, `VolumesLogField` | this element may refer to a local microservice project, mapped by `MicroserviceProjectArtifactsModel` element, or to an image of an external service, e.g. located in Docker hub repository.  
`ContainerDependency` | `DependencyOrder` | this element represents an ordered dependency association between one dependent / consumer `ContainerDefinition` element to one or many `ContainerDefinition` ‘provider’ elements. 
`SystemProjectBuildFile` | `ProjectArtifactId` | this element is a generalization of any artefact generated by a build framework used to compile the root project along with its subprojects. For example, two frameworks were found in the selected studies used to build `Spring Boot` applications; `Maven`and `Gradle`. Maven build file is an XML representation of a project held in a file named `pom.xml`. POM stands for "Project Object Model". A **Maven** project could represent an entire system project or an individual micro service’s project. A system root project consisting of subprojects and built by Maven framework will have names of its subprojects enclosed between `<module></module>` XML ele-ment. **Gradle** build file is a settings file used by Gradle framework to assemble the project description, its sub-projects and dependencies for a build. Its name is `settings.gradle` and it uses `include` commands to build related subprojects. Unsurprisingly, a `SystemProjectBuildFile` element references all ‘local’ subprojects constructing an architecture project where each subproject is represented by `MicroserviceProjectArtifactsModel` element. 
`MicroserviceProjectArtifactsModel` | `ModuleName` | this element is simply an aggregation of all artefacts generated by `Spring Framework` and related to one ‘local’ microservice project composing an architecture project. `MicroserviceProjectArtifactsModel` has elements corresponding to a particular type of microservice project artefact file. 

## 2. MicroserviceProjectArtifactsModel

Represents *microservice-level* project artefacts.  `MicroserviceProjectArtifactsModel` element is composed of many elements that model different types of system project artefacts and their content as explained in the following:

PSM Concept | PSM Attribute(s) | Description
------------ | ------------- | -------------
`MicroserviceProjectArtifactFile` | `ProjectName`, `ArtifactFileName` | this element generalizes artefacts generated by Spring framework and related to one microservice project including container’s build, application’s build, application’s configurations as well as application’s java source files. Typically, these files are generated and required for any java project built using `Spring Framework`. However, this generalized element can be extended to include additional and new artefact types.
`DockerFile` | `CommandFROM`, `CommandRUN` | this element maps to one `Dockerfile` which is a script file that is used to run service container’s image inside Docker. File structure consists of many commands out of which only two commands were considered; `FROM` whose argument is the application’s image name and `RUN` whose argument is a set of commands required to deploy the application.
`MicroserviceProjectBuildFile` | `ProjectParentArtifactId` | this element is similar in purpose to `SystemProjectBuildFile` except that it is generated for one microservice project instead of multi-module system project. The structure of this file consist of one or many `DependencyLibrary` elements. 
`DependencyLibrary` | `LibraryGroupName`, `LibraryName`, `LibraryScope` | this element that matches the `<dependency></dependency>` XML elements in `pom.xml` or the argument’s value of `compile` commands in `build.gradle` file. It simply lists the project’s software dependencies. `DependencyLibrary` element has three attributes: `LibraryGroupName`, `LibraryName` and `LibraryScope`. LibraryScope refers to the particular execution environment of the application in which a component should be attached. 
`MicroserviceProjectConfigurationsFile` | | this element maps to one ‘consolidated’ file merged by many YAML configuration files created particularly by Java’s spring framework for every Spring application. This includes `application.properties`, `application.yml` and / or `bootstrap.yml` files. A `MicroserviceProjectConfigurationsFile` consists of many `ConfigurationProperty` elements.
`ConfigurationProperty` | `FullyQualifiedPropertyName`, `PropertyValue`, `ConfigurationProfile` | this element defines important functionality and execution information. These configuration files could be either packaged locally within the application artefacts or located in a remote centralized service to facilitate sharing of updates in the configurations of distributed services. `ConfigurationProperty` element has `ConfigurationProfile` attribute that refers to `spring.profiles` property defining the particular execution environment of the application in which a property should be applied.
`JavaSourceFile` | | this element maps to every java source file created for a microservice Spring application. We decided to use our own simplified java metamodel. For example, java control flow statements, e.g. `if-then` and `for-loop` statement, as well as expressions, e.g. arithmetic and logical, are not considered at all. In addition, class definitions, declarations of local java fields and method invocations are elaborated no further than needed for our study. Basically, we define a java file to contain many `JavaElement`s.
`JavaElement` | `ElementIdentifier` | this element could either be a `JavaDataType`, `JavaMethod` or `JavaField`. A `JavaElement` is defined by its name, i.e. identifier. Spring framework defines the role of each `JavaElement` by using its set of tailored `JavaAnnotation`s which, in turn, may have one or many `JavaAnnotationParameter`s. 
`JavaAnnotation` | `AnnotationName` |  
`JavaAnnotationParameter` | `ParameterName`, `ParameterValue` | 
`JavaDataType` | `IsPrimitive`, `JsonSchema`, `PackageName`  |  `JavaDataType` is either primitive (e.g. int, float, char or Boolean) or `JavaUserDefinedType` which, in turn, can be a `JavaInterfaceType` or a `JavaClassType`. A `JavaDataType` is defined by `JsonSchema`, i.e. JSON representation of type definition, and `PackageName` and it represents the type of any `JavaField` element. 
`JavaUserDefinedType` | | this element may extend and/or import other `JavaUserDefinedType` elements and it contains one or many `JavaMethods`. It is also the parent of any `JavaMethod` element. 
`JavaClassType` | | A `JavaClassType` can implement a `JavaInterfaceType`and it may contain local `JavaField`s in addition to `JavaMethod`s. 
`JavaInterfaceType` | | 
`JavaMethod` | | A `JavaMethod` may take instances of `JavaField` as input parameters in its signature and/or as local fields in its body. It may return at most one instance of `JavaDataType` and invoke other `JavaMethod`s. 
`JavaField` | `FieldValue` | 

<br/>

*ECORE* implementation of the above PSM model is provided in `PSM.ecore` file.
